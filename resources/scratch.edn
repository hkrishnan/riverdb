(d/q '[:find ?e .
       :where [?e :sitevisit/SiteVisitID]]
  (db))

(d/q '[:find [(pull ?sv [* {:sitevisit/QAPerson [*]}]) ...]
       :in $ ?sv
       :where
       [?sv :sitevisit/QAPerson ?pid]
       [?p :person/PersonID ?pid]]
  (db) 17592186213031)

:sitevisit/DataEntryPersonRef :sitevisit/CheckPersonRef :sitevisit/QAPersonRef

[[:sitevisit/QAPersonRef :one :ref "Who did QA for this sitevisit?"]
 [:sitevisit/CheckPersonRef :one :ref "Who Checked this sitevisit?"]
 [:sitevisit/DataEntryPersonRef :one :ref "Who did the data entry for this sitevisit?"]]

(defn useDroppable
  ([this state-k] (useDroppable this state-k nil))
  ([this state-k type-k]
   (let [set-state!  (fn [new-state] (set-dnd-state! this new-state))
         inState     (fn []
                       (let [state (comp/get-state this :dnd-state)
                             state' (state-k state)]
                         (debug "inState" state' state)
                         state'))

         isType      (fn [type] (if type-k (= type type-k) true))
         isOver      (fn [] (and (isType (:type @dragging)) (inState)))
         onDragOver  (fn [e fn]
                       (let [{:keys [text type] :as data} @dragging]
                         (debug "DRAG OVER ATOM" state-k type text (isType type) (inState))
                         (cancelEvs e)
                         (when (and (isType type) (not (inState)))
                           (set-state! {state-k true})
                           (when fn (fn data)))))
         onDragLeave (fn [e fn]
                       (let [{:keys [text type] :as data} @dragging]
                         (debug "DRAG LEAVE ATOM" state-k type text)
                         (cancelEvs e)
                         (when (isOver)
                           (set-state! {state-k nil})
                           (when fn (fn data)))))
         onDrop      (fn [e fn]
                       (let [{:keys [text type] :as data} @dragging]
                         (debug "DROP ATOM" state-k type text (isType type) (inState))
                         (cancelEvs e)
                         (when (isOver)
                           (set-state! {state-k nil})
                           (when fn (fn data)))))]
     {:isOver isOver :onDragOver onDragOver :onDragLeave onDragLeave :onDrop onDrop})))




;let counterHook = () => {
;                         let count = atom(0);
;                             let incCount = () => swap(count, inc);
;                         return [count, incCount]};
;
;
;let C = () => {
;               let [count, incCount] = counterHook();
;                   return () => <div onClick={incCount}>{deref(count)}</div>};


(defn useCounter [this]
  (let [count (or (comp/get-state this :count) 0)]
    {:count count :incCount #(comp/update-state! this assoc :count (inc count))}))

(div
  (let [{:keys [count incCount]} (useCounter this)]
    (button {:onClick incCount} count)))



(defsc Attribute [this props]
  {:ident :attr/key
   :query [:attr/key
           :attr/name
           :attr/type
           :attr/cardinality
           :attr/ref
           :attr/refkey]})

(defsc Entity [this props]
  {:ident :entity/ns
   :query [:entity/ns
           :entity/name
           :entity/lookup
           :entity/prKeys
           {:entity/attrs (comp/get-query Attribute)}]})

(defsc Filter [this props]
  {:query         [:key
                   :text
                   :filt
                   {:attr (comp/get-query Attribute)}]
   :initial-state (fn [{:keys [key text filt attr]}]
                    {:key  key
                     :text text
                     :filt filt
                     :attr (comp/get-initial-state Attribute attr)})})
(def ui-filter (comp/factory Filter))


(defsc Root [this {people :people}]
  {:query         [{:people (comp/get-query Person)}]
   :initial-state {:people [{:id 0 :name "Sally" :city "Nowhere" :state "GA"}
                            {:id 1 :name "Tom" :city "There" :state "OH"}]}})






'(in-ns 'user)
(require
  '[com.fulcrologic.fulcro.components :as comp :refer [defsc]]
  '[com.fulcrologic.fulcro.algorithms.form-state :as fs]
  '[com.fulcrologic.fulcro.algorithms.normalize :as fnorm])
(defsc Person [this props]
  {:query       [:db/id ::person-name ::person-age
                 fs/form-config-join]
   :ident       [:person/id :db/id]
   :form-fields #{::person-name ::person-age}})
(def person {:db/id 1 ::person-name "Bo"})
(def person-form (fs/add-form-config Person person))
(def state-map (fnorm/tree->db [{:the-person (comp/get-query Person)}] {:the-person person-form} true))
(def modified-state-map (-> state-map
                          (assoc-in [:person/id 1 ::person-name] "Bobby")
                          (assoc-in [:person/id 1 ::person-age] 42)))
(defn merge-elide-keys
  "replace a subset of m1's keys ks with m2's, eliding any missing"
  ([m1 m2 ks]
   (persistent!
     (reduce-kv
       (fn [out k v]
         (if (not (contains? ks k))
           (assoc! out k v)
           (if (contains? m2 k)
             (assoc! out k (k m2))
             out)))
       (transient {}) m1))))

(defn pristine->entity*
  [state-map entity-ident]
  (fs/update-forms state-map
    (fn reset-form-step [e {:keys [::fs/pristine-state] :as config}]
      [(merge e pristine-state) config]) entity-ident))

(defn pristine->entity-1
  [state-map entity-ident]
  (fs/update-forms state-map
    (fn reset-form-step [e {:keys [::fs/pristine-state ::fs/fields] :as config}]
      [(merge-elide-keys e pristine-state fields) config]) entity-ident))

(defn pristine->entity-2
  [state-map entity-ident]
  (fs/update-forms state-map
    (fn reset-form-step [e {:keys [::fs/pristine-state] :as config}]
      [(as-> e e (apply dissoc e (::fs/fields config)) (merge e pristine-state)) config]) entity-ident))

(defn pristine->entity-3
  [state-map entity-ident]
  (fs/update-forms state-map
    (fn reset-form-step [e {:keys [::fs/pristine-state ::fs/fields] :as config}]
      (let [new-e      (merge e pristine-state)
            elide-keys (clojure.set/difference fields (keys pristine-state))
            new-e      (apply dissoc new-e elide-keys)]
        [new-e config])) entity-ident))

(def reset-state-map-*    (pristine->entity* modified-state-map [:person/id 1]))
(def reset-state-map-1    (pristine->entity-1 modified-state-map [:person/id 1]))
(def reset-state-map-2    (pristine->entity-2 modified-state-map [:person/id 1]))
(def reset-state-map-3    (pristine->entity-3 modified-state-map [:person/id 1]))

(= reset-state-map-* state-map)
=> false
(= reset-state-map-1 state-map)
=> true
(= reset-state-map-2 state-map)
=> true
(= reset-state-map-3 state-map)
=> true

'(use '[criterium.core :as bench])

(bench/quick-bench (pristine->entity-1 modified-state-map [:person/id 1]) :verbose)
(comment
  x86_64 Mac OS X 10.14.6 8 cpu(s)
  OpenJDK 64-Bit GraalVM CE 19.3.0 11.0.5+10-jvmci-19.3-b05-LTS
  Runtime arguments: -Dclojure.libfile=/private/var/folders/_j/l67rbgv937z5q7849589281w0000gn/T/libfile7.libs -javaagent:/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar=55520:/Applications/IntelliJ IDEA CE.app/Contents/bin -Dfile.encoding=UTF-8
  Evaluation count : 327648 in 6 samples of 54608 calls.
  Execution time sample mean : 1.867342 µs
  Execution time mean : 1.867023 µs
  Execution time sample std-deviation : 16.784794 ns
  Execution time std-deviation : 17.144893 ns
  Execution time lower quantile : 1.839771 µs ( 2.5%)
  Execution time upper quantile : 1.883676 µs (97.5%)
  Overhead used : 6.895278 ns)

(bench/quick-bench (pristine->entity-2 modified-state-map [:person/id 1]) :verbose)
(comment
  x86_64 Mac OS X 10.14.6 8 cpu(s)
  OpenJDK 64-Bit GraalVM CE 19.3.0 11.0.5+10-jvmci-19.3-b05-LTS
  Runtime arguments: -Dclojure.libfile=/private/var/folders/_j/l67rbgv937z5q7849589281w0000gn/T/libfile7.libs -javaagent:/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar=55520:/Applications/IntelliJ IDEA CE.app/Contents/bin -Dfile.encoding=UTF-8
  Evaluation count : 298680 in 6 samples of 49780 calls.
  Execution time sample mean : 2.060244 µs
  Execution time mean : 2.060134 µs
  Execution time sample std-deviation : 20.902451 ns
  Execution time std-deviation : 22.778221 ns
  Execution time lower quantile : 2.034660 µs ( 2.5%)
  Execution time upper quantile : 2.084416 µs (97.5%)
  Overhead used : 6.895278 ns)

(bench/quick-bench (pristine->entity-3 modified-state-map [:person/id 1]) :verbose)
(comment
  x86_64 Mac OS X 10.14.6 8 cpu(s)
  OpenJDK 64-Bit GraalVM CE 19.3.0 11.0.5+10-jvmci-19.3-b05-LTS
  Runtime arguments: -Dclojure.libfile=/private/var/folders/_j/l67rbgv937z5q7849589281w0000gn/T/libfile7.libs -javaagent:/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar=55520:/Applications/IntelliJ IDEA CE.app/Contents/bin -Dfile.encoding=UTF-8
  Evaluation count : 260310 in 6 samples of 43385 calls.
  Execution time sample mean : 2.356212 µs
  Execution time mean : 2.356579 µs
  Execution time sample std-deviation : 41.224805 ns
  Execution time std-deviation : 42.054627 ns
  Execution time lower quantile : 2.319385 µs ( 2.5%)
  Execution time upper quantile : 2.422673 µs (97.5%)
  Overhead used : 6.895278 ns

  Found 1 outliers in 6 samples (16.6667 %)
  low-severe   1 (16.6667 %)
  Variance from outliers : 13.8889 % Variance is moderately inflated by outliers)



(defsc AgeView [_ {:person/keys [age]}]
  {:query [:person/age],..}
  (p age))
(def ui-age-view (comp/factory AgeView))
(defsc Person [_ {:person/keys [name] :as person}]
  {:query [:person/id :person/name :person/age]}
  (div name (ui-age-view person)))